# 作者: VulnExpo
# 日期: 2023-10-20

import re
import requests
import argparse
from urllib.parse import urlparse
from requests.exceptions import RequestException
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

def check_for_vulnerability(url, proxies={}, success_file=None):
    SERVER_INFO_URI = '/server-info.action'
    VULNERABLE_VERSIONS = ['8.0.0', '8.0.1', '8.0.2', '8.0.3', '8.0.4', '8.1.0', '8.1.1', '8.1.3', '8.1.4', '8.2.0', '8.2.1', '8.2.2', '8.2.3', '8.3.0', '8.3.1', '8.3.2', '8.4.0', '8.4.1', '8.4.2', '8.5.0', '8.5.1']

    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36'}

    try:
        response = requests.get(url, headers=headers, verify=False, timeout=5)
        response.raise_for_status()
    except RequestException as err:
        print(f"连接到 {url} 时出现错误: {err}")
        return

    if 'Atlassian Confluence' not in response.text:
        print(f"{url} - 目标似乎不是 Atlassian Confluence. 跳过此目标.")
        return

    version_match = re.search(r'Atlassian Confluence ([\d\.]+)<', response.text)
    if not version_match:
        version_match = re.search(r'"ajs-version-number" content="([\d\.]+)"', response.text)

    if version_match:
        version = version_match.group(1)
        product = 'Atlassian Confluence'
    else:
        version = 'unknown'
        product = 'unknown'

    initial_vuln_status = 'not vulnerable'

    if version != 'unknown' and version in VULNERABLE_VERSIONS:
        initial_vuln_status = "potentially vulnerable"
    # 如果目标状态为 "not vulnerable"，则不保存到结果中
    if initial_vuln_status == 'not vulnerable':
        return

    target_info = {
        'target_url': url,
        'product': product,
        'version': version,
        'vulnerability_status': initial_vuln_status,
    }

    try:
        server_info_url = f"{url}{SERVER_INFO_URI}"
        response = requests.get(server_info_url, headers=headers, verify=False, allow_redirects=False, timeout=5)
        response.raise_for_status()
    except RequestException as err:
        print(f"{url} - 连接到 {server_info_url} 时出现错误: {err}")
        return

    if response.status_code != 200:
        print(f"{url} - 无法访问脆弱的端点 {SERVER_INFO_URI}，收到状态码 {response.status_code}。目标可能已打补丁.")
        if initial_vuln_status == 'potentially vulnerable':
            target_info['vulnerability_status'] = 'likely not exploitable'

    with open(success_file, 'a') as s_file:
        s_file.write("++++++++++++++++++\n")
        s_file.write(f"目标URL: {url}\n")
        s_file.write(f"产品: {product}\n")
        s_file.write(f"版本号: {version}\n")
        s_file.write(f"漏洞状态: {initial_vuln_status}\n\n")

def scan_targets(targets, proxies={}, success_file=None):
    for target in targets:
        target = target.strip()
        check_for_vulnerability(target, proxies, success_file)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Confluence 权限提升漏洞CVE-2023-22515")
    parser.add_argument("-u", "--url", help="目标URL")
    parser.add_argument("-f", "--file", default="url.txt", help="目标URL列表，默认为url.txt")
    args = parser.parse_args()

    if not args.url and not args.file:
        print("请使用 -u 指定要扫描的目标URL或使用默认文件 url.txt。")
        exit(1)

    if args.url:
        urls = [args.url]
    elif args.file:
        with open(args.file, 'r') as file:
            urls = file.readlines()

    proxies = {}
    success_file = 'success_targets.txt'

    for url in urls:
        url = url.strip()
        if not url.startswith("http://") and not url.startswith("https://"):
            scan_targets(["http://" + url, "https://" + url], proxies, success_file)
        else:
            scan_targets([url], proxies, success_file)

    print("扫描完成，成功的目标已保存到 success_targets.txt 文件中。")
